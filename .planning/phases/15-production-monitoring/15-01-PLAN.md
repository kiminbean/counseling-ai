---
phase: 15-production-monitoring
plan: 01
type: execute
depends_on: []
files_modified: [package.json, sentry.client.config.ts, sentry.server.config.ts, sentry.edge.config.ts, next.config.js, lib/monitoring.ts, app/layout.tsx, .env.local.example]
---

<objective>
Sentry 에러 트래킹 연동

Purpose: 프로덕션 환경에서 에러를 실시간으로 추적하고 디버깅할 수 있도록 함
Output: Sentry SDK 설치, 설정 파일, 에러 캡처 통합
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Research topics:** @sentry/nextjs 설정
**Key files:**
@lib/monitoring.ts
@next.config.js
@components/common/ErrorBoundary.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install and configure Sentry SDK</name>
  <files>package.json, sentry.client.config.ts, sentry.server.config.ts, sentry.edge.config.ts</files>
  <action>
  1. Install Sentry SDK:
     ```bash
     npm install @sentry/nextjs
     ```

  2. Create sentry.client.config.ts:
     ```typescript
     import * as Sentry from '@sentry/nextjs';

     Sentry.init({
       dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
       environment: process.env.NODE_ENV,
       tracesSampleRate: 0.1, // 10% of transactions
       replaysSessionSampleRate: 0.1,
       replaysOnErrorSampleRate: 1.0,
       enabled: process.env.NODE_ENV === 'production',
     });
     ```

  3. Create sentry.server.config.ts:
     ```typescript
     import * as Sentry from '@sentry/nextjs';

     Sentry.init({
       dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
       environment: process.env.NODE_ENV,
       tracesSampleRate: 0.1,
       enabled: process.env.NODE_ENV === 'production',
     });
     ```

  4. Create sentry.edge.config.ts (same as server)
  </action>
  <verify>npm run build succeeds with Sentry installed</verify>
  <done>Sentry SDK installed, config files created</done>
</task>

<task type="auto">
  <name>Task 2: Update next.config.js for Sentry integration</name>
  <files>next.config.js, .env.local.example</files>
  <action>
  1. Update next.config.js to wrap with Sentry:
     ```javascript
     const { withSentryConfig } = require('@sentry/nextjs');

     const nextConfig = {
       // existing config
     };

     module.exports = withSentryConfig(nextConfig, {
       silent: true,
       org: process.env.SENTRY_ORG,
       project: process.env.SENTRY_PROJECT,
     }, {
       widenClientFileUpload: true,
       transpileClientSDK: true,
       tunnelRoute: '/monitoring',
       hideSourceMaps: true,
       disableLogger: true,
     });
     ```

  2. Create/update .env.local.example:
     ```
     # Sentry (Production only)
     NEXT_PUBLIC_SENTRY_DSN=
     SENTRY_ORG=
     SENTRY_PROJECT=
     SENTRY_AUTH_TOKEN=
     ```
  </action>
  <verify>npm run build succeeds</verify>
  <done>next.config.js wrapped with Sentry, env example updated</done>
</task>

<task type="auto">
  <name>Task 3: Update monitoring.ts to use Sentry</name>
  <files>lib/monitoring.ts</files>
  <action>
  Update lib/monitoring.ts to actually use Sentry when available:

  1. Import Sentry conditionally (dynamic import to avoid build issues when DSN not set)

  2. Update captureError function:
     ```typescript
     export function captureError(error: Error | string, context?: ErrorContext): void {
       const errorObj = typeof error === 'string' ? new Error(error) : error;
       console.error('[Error]', errorObj.message, context);

       if (isProduction && typeof window !== 'undefined') {
         import('@sentry/nextjs').then((Sentry) => {
           Sentry.captureException(errorObj, {
             tags: { page: context?.page, action: context?.action },
             user: context?.userId ? { id: context.userId } : undefined,
             extra: { sessionId: context?.sessionId, ...context?.extra },
           });
         }).catch(() => {
           // Sentry not available, silent fail
         });
       }
     }
     ```

  3. Update setUser function to use Sentry.setUser()

  4. Keep console logging as fallback for development
  </action>
  <verify>npm run build && npm test</verify>
  <done>monitoring.ts uses Sentry for production error tracking</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npm test` passes all tests
- [ ] Sentry SDK installed in package.json
- [ ] sentry.client.config.ts, sentry.server.config.ts, sentry.edge.config.ts exist
- [ ] next.config.js wrapped with withSentryConfig
- [ ] lib/monitoring.ts uses Sentry for production
- [ ] .env.local.example has Sentry variables
</verification>

<success_criteria>
- Sentry SDK properly integrated
- Error tracking works in production (when DSN is set)
- Development mode uses console logging
- No build errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-production-monitoring/15-01-SUMMARY.md`
</output>
